# ID 生成器

ID 要求：

- 全局唯一，需要是唯一标识，不能出现重复的 ID 号，这是最基本的要求
- 单调递增，保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求
- 高性能，高QPS、低延迟
- 高可用性，可用性接近 5 个 9
- 信息安全，如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则
- 趋势递增，在MySQL InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能

## 自增 ID

```cpp
class IncID
{
public:
    int id() const
    { 
        return id_; 
    }

    static int nextID()
    {
        ++id_;
        return id_;
    }
private:
    static int id_;
};

int IncID::id_ = 0;
```

## UUID

UUID(Universally Unique Identifier)的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符，示例：550e8400-e29b-41d4-a716-446655440000，到目前为止业界一共有5种方式生成UUID，详情见IETF发布的UUID规范 A Universally Unique IDentifier (UUID) URN Namespace

性能非常高：本地生成，没有网络消耗, 但是不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。
信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置

ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用

## SnowFlake 算法

SnowFlake 算法是 Twitter 开源的分布式 ID 生成算法，结果是一个 long 型的 ID。

SnowFlake 算法的核心思想是：使用一个 64 bit 的 long 型的数字作为全局唯一 ID，其中有几个部分是固定的。

- 第一个部分，是 1 个 bit：0，这个是无意义的。
- 第二个部分是 41 个 bit：表示的是时间戳。
- 第三个部分是 5 个 bit：表示的是机房 ID，10001。
- 第四个部分是 5 个 bit：表示的是机器 ID，1 1001。
- 第五个部分是 12 个 bit：表示的序号，就是某个机房某台机器上这一毫秒内同时生成的 id 的序号，0000 00000000。

## 非加密 HASH 算法

适合标记 UI 中窗口的 ID, 便于查找窗口
