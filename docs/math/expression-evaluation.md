# 表达式求值

## 中缀表达式

中缀表示法是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例：3 + 4）。与前缀表达式（例：+ 3 4 ）或后缀表达式（例：3 4 + ）相比，中缀表达式不容易被电脑解析逻辑优先顺序，但仍被许多程序语言使用，因为它符合大多数自然语言的写法。

与前缀或后缀记法不同的是，中缀记法中括号是必需的。计算过程中必须用括号将操作符和对应的操作数括起来，用于指示运算的次序

## 波兰表示法

波兰表示法（Polish notation，或波兰记法），是一种逻辑、算术和代数表示方法，其特点是操作符置于操作数的前面，因此也称做前缀表示法。如果操作符的元数（arity）是固定的，则语法上不需要括号仍然能被无歧义地解析。波兰记法是波兰数学家扬·武卡谢维奇1920年代引入的，用于简化命题逻辑。
> 扬·武卡谢维奇本人提到：
我在1924年突然有了一个无需括号的表达方法，我在文章第一次使用了这种表示法。
——Łukasiewicz(1), p. 610, footnote.

表达“三加四”时，前缀记法写作`+34`，而不是`3+4`。在复杂的表达式中，操作符仍然在操作数的前面，但操作数可能是包含操作符的平凡表达式。 例如，中缀运算式`(5-6)*7`，在前缀表达式中可以表示为：`*(−56)7`或省略括号：`*-567`。由于简单的算术运算符都是二元的，该前缀表达式无需括号，且表述是无歧义的。在前面的例子里，中缀形式的括号是必需的，如果将括号移动到：`5-(6* 7)`即：`5-6*7`
则会改变整个表达式的值。而其正确的前缀形式是：
`-5*67`
减法运算要等它的两个操作数（5；6和7的乘积）都完成时才会处理。在任何表示法中，最里面的表达式最先运算，而在波兰表达式中，决定“最里面”的是顺序而不是括号。

简单算术的前缀表达式主要是用于学术研究方面。与逆波兰表示法不同，前缀表达式基本没有在商业计算器中使用过，但是其体系经常在编译器构造的概念教学中首先使用。

前缀表达式的运算顺序很容易检测。需注意的是，当运算时，操作符是作用在第一个操作数上，特别是需注意不满足交换律的运算，如除法、减法。例如，下列式子：`/ 10 5 = 2`，表示10/5，结果是2，而不是1/2

基于堆栈的操作符由于其本身的特性，无需括号也很容易区分运算的顺序，因此大量使用波兰记法。运算波兰表达式时，无需记住运算的层次，只需要直接寻找第一个运算的操作符。以二元运算为例，从左至右读入表达式，遇到一个操作符后跟随两个操作数时，则计算之，然后将结果作为操作数替换这个操作符和两个操作数；重复此步骤，直至所有操作符处理完毕。因为在正确的前缀表达式中，操作数必然比操作符多一个，所以必然能找到一个操作符符合运算条件；而替换时，两个操作数和一个操作符替换为一个操作数，所以减少了各一个操作符和操作数，仍然可以迭代运算直至计算整个式子。多元运算也类似，遇到足够的操作数即产生运算，迭代直至完成。迭代结束的条件由表达式的正确性来保证。下面是一个例子，演示了每一步的运算顺序：

```cpp
 - * / 15 - 7 + 1 1 3 + 2 + 1 1 =
 - * / 15 - 7   2   3 + 2 + 1 1 =
 - * / 15     5     3 + 2 + 1 1 =
 - *        3       3 + 2 + 1 1 =
 -          9         + 2 + 1 1 =
 -          9         + 2   2   =
 -          9         4         =
                5
```

## 逆波兰表示法

逆波兰表示法（Reverse Polish notation，RPN，或逆波兰记法），是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式形式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为后缀表示法、后序表示法。逆波兰记法不需要括号来标识操作符的优先级。

逆波兰结构由弗里德里希·鲍尔（Friedrich L. Bauer）和艾兹格·迪科斯彻在1960年代早期提议用于表达式求值，以利用堆栈结构减少计算机内存访问。逆波兰记法和相应的算法由澳大利亚哲学家、计算机学家查尔斯·汉布林（Charles Hamblin）在1960年代中期扩充。

在1960和1970年代，逆波兰记法广泛地被用于台式计算器，因此也在普通公众（如工程、商业和金融等领域）中使用。

逆波兰记法中，操作符置于操作数的后面。例如表达“三加四”时，写作“3 4 + ”，而不是“3 + 4”。如果有多个操作符，操作符置于第二个操作数的后面，所以常规中缀记法的“3 - 4 + 5”在逆波兰记法中写作“3 4 - 5 + ”：先3减去4，再加上5。使用逆波兰记法的一个好处是不需要使用括号。例如中缀记法中“3 - 4 * 5”与“（3 - 4）*5”不相同，但后缀记法中前者写做“3 4 5 * - ”，无歧义地表示“3 (4 5 *) -”；后者写做“3 4 - 5 * ”。

逆波兰表达式的解释器一般是基于堆栈的。解释过程一般是：操作数入栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，并且能很快求值。

注意：逆波兰记法并不是简单的波兰表达式的反转。因为对于不满足交换律的操作符，它的操作数写法仍然是常规顺序，如，波兰记法“/ 6 3”的逆波兰记法是“6 3 /”而不是“3 6 /”；数字的数位写法也是常规顺序。

艾兹格·迪科斯彻引入了调度场算法，用于将中缀表达式转换为后缀形式。因其操作类似于火车编组场而得名。 大多数操作符优先级解析器(解析器用简单的查表操作即可实现，优先级表由开发者自己定制，在不同的应用场景中，开发者可自由改变操作符的优先级)能转换为处理后缀表达式，实际中，一般构造抽象语法树，树的后序遍历即为逆波兰记法。

```cpp
while 有输入
读入下一个符号X
IF X是一个操作数
入栈
ELSE IF X是一个操作符
有一个先验的表格给出该操作符需要n个参数
IF堆栈中少于n个操作数
（错误） 用户没有输入足够的操作数
Else，n个操作数出栈
计算操作符。
将计算所得的值入栈
IF栈内只有一个值
这个值就是整个计算式的结果
ELSE多于一个值
（错误） 用户输入了多余的操作数
```

当有操作符时就计算，因此，表达式并不是从右至左整体计算而是每次由中心向外计算一部分，这样在复杂运算中就很少导致操作符错误。
堆栈自动记录中间结果，这就是为什么逆波兰计算器能容易对任意复杂的表达式求值。与普通科学计算器不同，它对表达式的复杂性没有限制。
逆波兰表达式中不需要括号，用户只需按照表达式顺序求值，让堆栈自动记录中间结果；同样的，也不需要指定操作符的优先级。
逆波兰计算器中，没有“等号”键用于开始计算。
逆波兰计算器需要“确认”键用于区分两个相邻的操作数。
机器状态永远是一个堆栈状态，堆栈里是需要运算的操作数，栈内不会有操作符。
教育意义上，逆波兰计算器的使用者必须懂得要计算的表达式的含义。
