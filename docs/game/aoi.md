# AOI

AOI 全称 Area Of Interest, 在游戏开发中用来做角色视野内对象显示同步和状态同步，基本上只要有公共地图的游戏都会涉及到

## 全局可见

一个最简单的实现方法是，场景中的所有对象在后端全都互相可见，任何对象的状态修改都会同步给全部的其它对象，在某个客户端上是否要显示某个对象完全依靠客户端来进行选择

这种最大的问题有两个，第一个是性能问题，毕竟每次更新都要广播给全部的对象，如果只有几十个对象还能用，多了就不太行了。第二个就是外挂问题，全部可以见意味着全部发送，这样客户端就有全部的对象数据，外挂可以直接拿到

存储数据也很简单，只保存一个全局的对象表就可以了，对象发生了任何要广播的事件就给剩下全部对象广播

## 非全局可见

在非全局可见的实现中，每个对象要维护一个被关注列表，它是指包含了所有能看到自己的对象的集合，自己的状态改变需要同步给集合中的所有对象

在对象有状态需要更新的情况下，直接广播消息给被关注列表的所有对象即可。比较麻烦的是加入场景和在场景中移动，因为这两种情况下对象需要维护自己的被关注列表，同时也需要更新自己可见的对象的被关注列表

自己可见的对象比较容易查询，因为有自己的视距和坐标，遍历范围内所有位置可以拿到所有自己可见的对象，把自己加入到它们的被关注列表即可。在维护自己的被关注列表时会碰到问题，因为自己并不知道其它对象的视距，所以不能直接遍历周围范围拿到

处理这个问题最简单的方法就是遍历场景上全部的对象，依次计算距离并且与它的视距比较，判断是否可以看见新加入的对象。这种方法只能用在地图比较小的情况下，如果地图很大，那么全局遍历一次是很难接受的

另一种方法就是限制最大视距，因为一般来说不会存在无限视距的对象，所以可以对场景设置一个硬性的视距上限值，任何类型的对象视距都不能超过它。这样在遍历的时候只需要检查最大视距以内的所有对象即可。并且此时可以发现，因为触发修改的对象的视距也不会超过最大视距，所以可以合并两次遍历，即可以通过对最大视距范围内对象的一次遍历完成自己的被关注列表和自己可以看到的对象的被关注列表的更新

根据业务需要也可以考虑增加一个关注列表，即自己可以看到的所有对象的集合。因为在业务中可能需要获取某个对象能看见的全部对象，如果只维护了被关注列表的话，这个获取就会非常麻烦。维护关注列表并不需要额外的计算，只需要在更新自己可以看到的对象的被关注列表时把它加入到自己的关注列表里即可

## 优化思路

### 划分格子

如果以像素为单位遍历地图的话有点太耗费性能了，而且绝大多数业务也不需要这么高的精度，所以一般都会把地图划分成更大的格子来处理

比如坐标格子精度为 64 个像素，那么从 (0, 0) 到 (63, 63) 内的所有对象的相对坐标都是 (0, 0)。每个格子会保存一个当前格子内全部对象以 id 为 key 的哈希结构，查询到格子以后可以方便遍历，离开格子时也可以快速移除

### 相等视距

如果游戏中的所有对象的视距都相等的话，那么 AOI 的问题可以被简化很多

当视距全都相等时，可以考虑省略掉为每个对象维护的集合，只对每个坐标维护一个对象列表。因为不管怎么改变，都可以根据对象的位置快速确定有关的坐标点，从而拿到全部的需要处理的对象

如果视距相等并且不需要高精度的情况下，可以结合划分格子的思路，这就是一个常见的实现，“九宫格法” AOI 的思路，它将每个对象的视野限制为以自己为中心格子的九宫格中

### 十字链表

AOI 算法中还有一个广泛使用的十字链表法，它本身很有特点，跟上面的思路大相径庭
